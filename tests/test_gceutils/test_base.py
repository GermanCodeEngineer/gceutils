from __future__ import annotations
import pytest
from typing import Any
from gceutils.base import AbstractTreePath, grepr_dataclass, field


class TestAbstractTreePath:
    """Test AbstractTreePath class."""
    
    def test_empty_path(self):
        """Test creating an empty path."""
        path = AbstractTreePath()
        assert len(path) == 0
        assert str(path) == "AbstractTreePath()"
    
    def test_add_attribute(self):
        """Test adding an attribute to the path."""
        path = AbstractTreePath()
        new_path = path.add_attribute("name")
        assert len(new_path) == 1
        assert ".name" in repr(new_path)
    
    def test_add_attribute_chain(self):
        """Test chaining multiple attribute additions."""
        path = AbstractTreePath()
        new_path = path.add_attribute("obj").add_attribute("field")
        assert len(new_path) == 2
        assert ".obj" in repr(new_path)
        assert ".field" in repr(new_path)
    
    def test_add_index_or_key_int(self):
        """Test adding an integer index."""
        path = AbstractTreePath()
        new_path = path.add_index_or_key(0)
        assert len(new_path) == 1
        assert "[0]" in repr(new_path)
    
    def test_add_index_or_key_str(self):
        """Test adding a string key."""
        path = AbstractTreePath()
        new_path = path.add_index_or_key("key")
        assert len(new_path) == 1
        assert '["key"]' in repr(new_path) or "['key']" in repr(new_path)
    
    def test_add_index_or_key_chain(self):
        """Test chaining indices and keys."""
        path = AbstractTreePath()
        new_path = path.add_index_or_key(0).add_index_or_key("key").add_index_or_key(5)
        assert len(new_path) == 3
    
    def test_path_immutability(self):
        """Test that paths are immutable."""
        path = AbstractTreePath()
        new_path = path.add_attribute("test")
        assert len(path) == 0  # Original unchanged
        assert len(new_path) == 1
    
    def test_path_with_dot_start(self):
        """Test path created with start_with_dot=True."""
        path = AbstractTreePath(start_with_dot=True).add_attribute("value")
        path_str = str(path)
        assert "." in path_str or path_str == "."


class TestGreprDataclass:
    """Test grepr_dataclass decorator."""
    
    def test_grepr_dataclass_basic(self):
        """Test basic grepr_dataclass functionality."""
        @grepr_dataclass()
        class TestClass:
            name: str
            value: int
        
        obj = TestClass(name="test", value=42)
        assert obj.name == "test"
        assert obj.value == 42
    
    def test_grepr_dataclass_with_defaults(self):
        """Test grepr_dataclass with default values."""
        @grepr_dataclass()
        class TestClass:
            name: str
            value: int = 10
        
        obj = TestClass(name="test")
        assert obj.value == 10
    
    def test_grepr_dataclass_repr(self):
        """Test that repr is overridden."""
        @grepr_dataclass()
        class TestClass:
            name: str
        
        obj = TestClass(name="test")
        repr_str = repr(obj)
        assert "TestClass" in repr_str
        assert "name" in repr_str
        assert "test" in repr_str
    
    def test_grepr_dataclass_frozen(self):
        """Test frozen grepr_dataclass."""
        @grepr_dataclass(frozen=True)
        class FrozenClass:
            value: int
        
        obj = FrozenClass(value=42)
        assert obj.value == 42
    
    def test_grepr_dataclass_no_init(self):
        """Test grepr_dataclass with init=False."""
        @grepr_dataclass(init=False)
        class NoInitClass:
            value: int = 10

        # init=False means no __init__ is generated by dataclass
        # So we can't use the normal constructor
        # But we can manually create instances if needed
        obj = object.__new__(NoInitClass)
        obj.value = 42
        assert obj.value == 42
    
    def test_grepr_dataclass_validate(self):
        """Test that validate method exists."""
        @grepr_dataclass(validate=True)
        class ValidatedClass:
            name: str
            count: int
        
        obj = ValidatedClass(name="test", count=5)
        # Should have validate method
        assert hasattr(obj, 'validate')
        assert callable(obj.validate)
        
        # Validate should not raise for correct types
        obj.validate()
    
    def test_grepr_dataclass_forbid_init_only_subcls(self):
        """Test forbid_init_only_subcls feature."""
        @grepr_dataclass(forbid_init_only_subcls=True, init=False)
        class ParentClass:
            value: int = 10
        
        class ChildClass(ParentClass):
            pass
        
        # Should raise when trying to instantiate parent directly
        with pytest.raises(NotImplementedError, match="Can not initialize parent class"):
            ParentClass()
        
        # Should work for subclass
        obj = object.__new__(ChildClass)
        obj.value = 42
        assert obj.value == 42
    
    def test_grepr_dataclass_post_validate(self):
        """Test that post_validate is called during validation."""
        called = []
        
        @grepr_dataclass(validate=True)
        class WithPostValidate:
            value: int
            
            def post_validate(self, path, *args, **kwargs):
                called.append((path, args, kwargs))
        
        obj = WithPostValidate(value=42)
        obj.validate()
        assert len(called) == 1
    
    def test_grepr_dataclass_validate_with_path(self):
        """Test validate with custom path."""
        from gceutils.base import AbstractTreePath
        
        @grepr_dataclass(validate=True)
        class ValidatedClass:
            name: str
        
        obj = ValidatedClass(name="test")
        custom_path = AbstractTreePath().add_attribute("custom")
        obj.validate(path=custom_path)  # Should not raise
    
    def test_grepr_dataclass_validate_type_false(self):
        """Test field with validate_type=False skips type checking."""
        @grepr_dataclass(validate=True)
        class SkipTypeCheck:
            name: str = field(validate_type=False)
            count: int
        
        obj = SkipTypeCheck(name=123, count=5)  # name is int but validate_type=False
        obj.validate()  # Should not raise because validate_type=False for name
    
    def test_grepr_dataclass_validate_require_exist_false(self):
        """Test field with validate_require_exist=False."""
        @grepr_dataclass(validate=True)
        class OptionalField:
            required: str
            optional: int = field(default=10, validate_require_exist=False)
        
        obj = OptionalField(required="test")
        # Delete the optional field to test validate_require_exist=False
        del obj.__dict__['optional']
        obj.validate()  # Should not raise even though optional is missing
    
    def test_grepr_dataclass_validate_require_exist_true_missing(self):
        """Test that missing required field raises error."""
        from gceutils.errors import GU_TypeValidationError
        
        @grepr_dataclass(validate=True, init=False)
        class RequiredField:
            name: str = field(validate_require_exist=True)
        
        obj = object.__new__(RequiredField)
        # Don't set the field at all (no __dict__ entry)
        with pytest.raises(GU_TypeValidationError, match="<not set>"):
            obj.validate()
    
    def test_grepr_dataclass_call_subvalidate(self):
        """Test call_subvalidate option."""

        @grepr_dataclass(validate=True)
        class NestedClass:
            value: int
        
        @grepr_dataclass(validate=True)
        class ParentClass:
            nested: Any = field(call_subvalidate=True)
        
        nested = NestedClass(value=42)
        parent = ParentClass(nested=nested)
        parent.validate()  # Should call nested.validate()


class TestField:
    """Test the custom field function."""
    
    def test_field_validator_fn_not_callable(self):
        """Test that validator_fn must be callable."""
        with pytest.raises(ValueError, match="validator_fn must be a function or callable"):
            field(validator_fn="not_callable")
    
    def test_field_basic_creation(self):
        """Test basic field creation."""
        f = field()
        assert f is not None
    
    def test_field_with_default(self):
        """Test field with default value."""
        f = field(default=42)
        assert f.default == 42
    
    def test_field_with_default_factory(self):
        """Test field with default factory."""
        f = field(default_factory=list)
        assert callable(f.default_factory)
    
    def test_field_grepr_option(self):
        """Test field with grepr option."""
        f = field(grepr=False)
        assert f is not None
    
    def test_field_in_dataclass(self):
        """Test using field in a dataclass."""
        @grepr_dataclass()
        class TestClass:
            items: list = field(default_factory=list)
            name: str = field(default="default")
        
        obj = TestClass()
        assert obj.items == []
        assert obj.name == "default"


class TestNotSetType:
    """Test NotSetType class."""
    
    def test_notset_repr(self):
        """Test NotSetType repr."""
        from gceutils.base import NotSet
        assert repr(NotSet) == "NotSet"
    
    def test_notset_bool(self):
        """Test NotSetType bool evaluation."""
        from gceutils.base import NotSet
        assert not NotSet
        assert bool(NotSet) is False


class TestAbstractTreePathAdvanced:
    """Advanced tests for AbstractTreePath."""
    
    def test_init_non_iterable_path(self):
        """Test AbstractTreePath init with non-iterable path."""
        from gceutils.base import AbstractTreePath
        with pytest.raises(ValueError, match="path must be an iterable"):
            AbstractTreePath(path=42)
    
    def test_init_invalid_path_items(self):
        """Test AbstractTreePath init with invalid path items."""
        from gceutils.base import AbstractTreePath
        with pytest.raises(ValueError, match="path must be an iterable of ATPathAttribute or ATPathIndexOrKey"):
            AbstractTreePath(path=["not", "valid"])
    
    def test_add_attribute_non_string(self):
        """Test add_attribute with non-string."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath()
        with pytest.raises(ValueError, match="attr must be a string"):
            path.add_attribute(42)
    
    def test_extend_non_abstracttreepath(self):
        """Test extend with non-AbstractTreePath."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath()
        with pytest.raises(ValueError, match="first argument must be an AbstractTreePath"):
            path.extend("not_a_path")
    
    def test_go_up_non_int(self):
        """Test go_up with non-int."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath().add_attribute("test")
        with pytest.raises(ValueError, match="n must be a int"):
            path.go_up("not_int")
    
    def test_index_invalid_type(self):
        """Test index with invalid type."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath()
        with pytest.raises(ValueError, match="value must be an ATPathAttribute or ATPathIndexOrKey"):
            path.index("invalid")
    
    def test_getitem_invalid_type(self):
        """Test __getitem__ with invalid type."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath()
        with pytest.raises(ValueError, match="first argument must be an index or slice"):
            path["invalid"]
    
    def test_add_non_abstracttreepath(self):
        """Test __add__ with non-AbstractTreePath."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath()
        with pytest.raises(ValueError, match="first argument must be an AbstractTreePath"):
            path + "invalid"
    
    def test_contains_invalid_type(self):
        """Test __contains__ with invalid type."""
        from gceutils.base import AbstractTreePath, ATPathAttribute
        path = AbstractTreePath().add_attribute("test")
        with pytest.raises(ValueError, match="first argument must be an ATPathAttribute or ATPathIndexOrKey"):
            "invalid" in path
    
    def test_contains_valid_item(self):
        """Test __contains__ with valid item."""
        from gceutils.base import AbstractTreePath, ATPathAttribute
        path = AbstractTreePath().add_attribute("test")
        attr = ATPathAttribute("test")
        assert attr in path
    
    def test_reversed(self):
        """Test __reversed__."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath().add_attribute("a").add_attribute("b").add_attribute("c")
        reversed_list = list(reversed(path))
        assert len(reversed_list) == 3
    
    def test_repr_as_python_code_without_dot_start(self):
        """Test repr_as_python_code with start_with_dot=False."""
        from gceutils.base import AbstractTreePath
        path = AbstractTreePath(start_with_dot=False).add_attribute("name").add_index_or_key(0)
        code = path.repr_as_python_code()
        assert not code.startswith(".")
        assert "name" in code
        assert "[0]" in code
    
    def test_get_in_tree_attribute_error(self):
        """Test get_in_tree with AttributeError."""
        from gceutils.base import AbstractTreePath
        
        class Obj:
            pass
        
        obj = Obj()
        path = AbstractTreePath().add_attribute("nonexistent")
        with pytest.raises(ValueError, match="Failed to get attribute"):
            path.get_in_tree(obj)
    
    def test_get_in_tree_with_default(self):
        """Test get_in_tree with default value."""
        from gceutils.base import AbstractTreePath
        
        obj = {"a": 1}
        path = AbstractTreePath().add_index_or_key("nonexistent")
        result = path.get_in_tree(obj, default="default_value")
        assert result == "default_value"
    
    def test_get_in_tree_attribute_with_default(self):
        """Test get_in_tree attribute access with default value."""
        from gceutils.base import AbstractTreePath
        
        class Obj:
            pass
        
        obj = Obj()
        path = AbstractTreePath().add_attribute("nonexistent")
        result = path.get_in_tree(obj, default="default_attr")
        assert result == "default_attr"
    
    def test_get_in_tree_index_error(self):
        """Test get_in_tree with IndexError."""
        from gceutils.base import AbstractTreePath
        
        obj = [1, 2, 3]
        path = AbstractTreePath().add_index_or_key(10)
        with pytest.raises(ValueError, match="Failed to get index or key"):
            path.get_in_tree(obj)
    
    def test_get_in_tree_keys_special_case(self):
        """Test get_in_tree with dict keys() special case."""
        from gceutils.base import AbstractTreePath
        
        obj = {"a": 1, "b": 2}
        path = AbstractTreePath().add_attribute("keys()").add_index_or_key(0)
        result = path.get_in_tree(obj)
        assert result in ["a", "b"]
    
    def test_exists_in_tree_true(self):
        """Test exists_in_tree returns True for valid path."""
        from gceutils.base import AbstractTreePath
        
        class Obj:
            value = 42
        
        obj = Obj()
        path = AbstractTreePath().add_attribute("value")
        assert path.exists_in_tree(obj) is True
    
    def test_exists_in_tree_false(self):
        """Test exists_in_tree returns False for invalid path."""
        from gceutils.base import AbstractTreePath
        
        obj = {}
        path = AbstractTreePath().add_index_or_key("nonexistent")
        assert path.exists_in_tree(obj) is False
    
    def test_set_in_tree_attribute(self):
        """Test set_in_tree for attribute."""
        from gceutils.base import AbstractTreePath
        
        class Obj:
            value = 0
        
        obj = Obj()
        path = AbstractTreePath().add_attribute("value")
        path.set_in_tree(obj, 42)
        assert obj.value == 42
    
    def test_set_in_tree_index(self):
        """Test set_in_tree for index."""
        from gceutils.base import AbstractTreePath
        
        obj = [1, 2, 3]
        path = AbstractTreePath().add_index_or_key(1)
        path.set_in_tree(obj, 99)
        assert obj[1] == 99
    
    def test_set_in_tree_attribute_error(self):
        """Test set_in_tree with AttributeError."""
        from gceutils.base import AbstractTreePath
        
        obj = object()  # Can't set attributes on plain object
        path = AbstractTreePath().add_attribute("value")
        with pytest.raises(AttributeError, match="Failed to set attribute"):
            path.set_in_tree(obj, 42)
    
    def test_set_in_tree_index_error(self):
        """Test set_in_tree with TypeError for index."""
        from gceutils.base import AbstractTreePath
        
        obj = "immutable_string"
        path = AbstractTreePath().add_index_or_key(0)
        with pytest.raises(TypeError, match="Failed to set index or key"):
            path.set_in_tree(obj, "x")
    
    def test_copy(self):
        """Test copy method."""
        from gceutils.base import AbstractTreePath
        
        path = AbstractTreePath().add_attribute("test")
        copied = path.copy()
        assert path == copied
        assert path is not copied
    
    def test_slice_getitem(self):
        """Test slicing AbstractTreePath."""
        from gceutils.base import AbstractTreePath
        
        path = AbstractTreePath().add_attribute("a").add_attribute("b").add_attribute("c")
        sliced = path[1:]
        assert len(sliced) == 2
        assert isinstance(sliced, AbstractTreePath)
    
    def test_index_method(self):
        """Test index method finds correct position."""
        from gceutils.base import AbstractTreePath, ATPathAttribute
        
        path = AbstractTreePath().add_attribute("a").add_attribute("b")
        attr_b = ATPathAttribute("b")
        idx = path.index(attr_b)
        assert idx == 1
    
    def test_extend(self):
        """Test extend method."""
        from gceutils.base import AbstractTreePath
        
        path1 = AbstractTreePath().add_attribute("a")
        path2 = AbstractTreePath().add_attribute("b")
        extended = path1.extend(path2)
        assert len(extended) == 2
    
    def test_add_operator(self):
        """Test + operator for path concatenation."""
        from gceutils.base import AbstractTreePath
        
        path1 = AbstractTreePath().add_attribute("a")
        path2 = AbstractTreePath().add_attribute("b")
        combined = path1 + path2
        assert len(combined) == 2
    
    def test_go_up(self):
        """Test go_up method."""
        from gceutils.base import AbstractTreePath
        
        path = AbstractTreePath().add_attribute("a").add_attribute("b").add_attribute("c")
        up_one = path.go_up(1)
        assert len(up_one) == 2
        up_two = path.go_up(2)
        assert len(up_two) == 1
